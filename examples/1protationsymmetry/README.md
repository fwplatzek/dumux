<!-- Important: This file has been automatically generated by generate_example_docs.py. Do not edit this file directly! -->

# Rotation-symmetric pressure distribution

__In this example, you will learn how to__

* solve a rotation-symmetric problem one-dimensionally
* perform a convergence test against an analytical solution
* apply the `Rotational Extrusion` filters in [ParaView](https://www.paraview.org/) for a two-dimensional visualization of the one-dimensional results


__Result__. With the `Rotational Extrusion` and the `Warp By Scalar` filter in [ParaView](https://www.paraview.org/),
the pressure distribution of this example looks as shown in the following picture:

<figure>
    <center>
        <img src="img/result.png" alt="Rotation-symmetric pressure distribution" width="60%"/>
        <figcaption> <b> Fig.1 </b> - Result TODO.</figcaption>
    </center>
</figure>


__Table of contents__. This description is structured as follows:

[[_TOC_]]


## Problem setup

We consider a single-phase problem that leads to a rotation-symmetric pressure distribution.
The following figure illustrates the setup:

<figure>
    <center>
        <img src="img/setup.svg" alt="Rotation-symmetric setup" width="60%"/>
        <figcaption> <b> Fig.1 </b> - Setup for the rotation-symmetric problem. The pressure boundary conditions are shown by the colored lines and the simulation domain is depicted in grey.</figcaption>
    </center>
</figure>

This could, for example, represent a cross section of an injection/extraction well in a homogeneous
and isotropic porous medium, where the well with radius $`r_1`$ is cut out and the
injection/extraction pressure $`p_1`$ is prescribed as a Dirichlet boundary condition. At the outer
radius $`r_2`$, we set the pressure $`p_2`$. In the polar coordinates $`r`$ and $`\varphi`$, the
solution to this problem is independent of the angular coordinate $`\varphi`$ and can be reduced to
a one-dimensional problem in the radial coordinate $`r`$. Therefore, in this example, we want to
solve the problem on a one-dimensional computational domain as illustrated by the orange line in
the above figure.

## Mathematical model

In this example we are using the single-phase model of DuMuX, which considers Darcy's law to relate
the Darcy velocity $`\textbf v`$ to gradients of the pressure $`p`$. For an isotropic medium and
neglecting gravitational forces, this can be written as:

```math
\textbf v = - \frac{k}{\mu} \text{grad} p.
```

Here, $`k`$ is the permeability of the porous medium and $`\varrho`$ and $`\mu`$ are the density
and the dynamic viscosity of the fluid. In the model, the mass balance equation for the fluid
phase is solved:

```math
\phi \frac{\partial \varrho}{\partial t} + \text{div} \left( \varrho \textbf v \right) = 0,
```

where $`\phi`$ is the porosity of the porous medium. Let us now introduce the transformation
$`(x, y)^T = \Phi ( r, \varphi )`$ from polar into cartesian coordinates (see e.g.
[wikipedia.org](https://en.wikipedia.org/wiki/Polar_coordinate_system#Converting_between_polar_and_Cartesian_coordinates)),
and denote with

```math
\tilde{p} \left( r, \varphi \right)
    = \tilde{p} \left( r \right)
    = p \left( \Phi^{-1}(x, y) \right)
```

and

```math
\tilde{\mathbf{v}} \left( r, \varphi \right)
    = \tilde{v}_r \left( r \right)
    = \mathbf{v} \left( \Phi^{-1}(x, y) \right)
```

the pressure and velocity distributions expressed in polar coordinates. The first identity
in the two above equations originates from the rotational symmetry of the problem and the
resulting independence of pressure and velocity on $`\varphi`$ in polar coordinates. Thus, in
polar coordinates we can write the mass balance equation as:

```math
\phi \frac{\partial \varrho}{\partial t}
   - \frac{\partial}{\partial r} \left( \frac{k}{\mu} \frac{\partial \tilde{p}}{\partial r} \right)
   = 0.
```

## Discretization

We employ a finite-volume scheme to spatially discretize the mass balance equation shown above.
The discrete equation describing mass conservation inside a control volume $`K`$ is obtained
by integration and reads:

```math
    | K | \left( \phi \, \partial \varrho / \partial t \right)_K
    + \sum_{\sigma \in \mathcal{S}_K} | \sigma | \left( \varrho v_r \right)_\sigma
    = 0,
```

where $`\sigma`$ are the faces of the control volume such that
$`\bigcup_{\sigma \in \mathcal{S}_K} \sigma \equiv \partial K`$ and where the notation $`( \cdot )_K`$
and $`( \cdot )_\sigma`$ was used to denote quantities evaluated for the control volume $`K`$ or a
face $`\sigma`$, respectively. The volume of the control volume is denoted with $`| K |`$ and
$`| \sigma |`$ is the area of a face.

Integration over polar coordinates requires taking into account the Jacobian determinant of the
coordinate transformation from polar to cartesian coordinates (see e.g.
[wikipedia.org](https://en.wikipedia.org/wiki/Polar_coordinate_system#Generalization)).
Let us discretize the domain by the intervals
$`K_i = (i\Delta r, (i+1)\Delta r) \times (0, 2 \Pi)`$,
$`i \in \{1, \dots, N \}`$, as control volumes.
As a result, their volumes are

```math
| K_i | = \Pi \left( ((i+1)*\Delta r)^2 - (i*\Delta r)^2 \right)
```

and the area of a face $`\sigma \in \mathcal{S}_{K_i}`$ is

```math
| \sigma | = 2 \Pi r_\sigma,
```

where $`r_\sigma`$ is the radius at which the face is defined.

# Implementation


## The problem class (`problem.hh`)
This file contains the __problem class__ which defines the initial and boundary
conditions for the single-phase flow simulation.

<details open>
<summary><b>Click to hide/show the file documentation</b> (or inspect the [source code](problem.hh))</summary>

### Includes

```cpp
#include <cmath> // for `std::log`
#include <dumux/common/properties.hh> // for `GetPropType`
#include <dumux/common/parameters.hh> // for `getParam`
#include <dumux/porousmediumflow/problem.hh>  // for `PorousMediumFlowProblem`
```

### The problem class
We enter the problem class where all necessary boundary conditions and initial conditions are set for our simulation.
As this is a porous medium flow problem, we inherit from the base class `PorousMediumFlowProblem`.

```cpp
namespace Dumux {

template<class TypeTag>
class RotSymExampleProblem : public PorousMediumFlowProblem<TypeTag>
{
    using ParentType = PorousMediumFlowProblem<TypeTag>;
    using GridGeometry = GetPropType<TypeTag, Properties::GridGeometry>;
    using Scalar = GetPropType<TypeTag, Properties::Scalar>;
    using PrimaryVariables = GetPropType<TypeTag, Properties::PrimaryVariables>;
    using BoundaryTypes = GetPropType<TypeTag, Properties::BoundaryTypes>;
    using Element = typename GridGeometry::GridView::template Codim<0>::Entity;
    using GlobalPosition = typename Element::Geometry::GlobalCoordinate;

public:
```

This is the constructor of our problem class:

```cpp
    RotSymExampleProblem(std::shared_ptr<const GridGeometry> gridGeometry)
    : ParentType(gridGeometry)
    {
        k_ = getParam<Scalar>("SpatialParams.Permeability");
        nu_ = getParam<Scalar>("Component.LiquidKinematicViscosity");
        q_ = getParam<Scalar>("Problem.Source");
        pW_ = getParam<Scalar>("Problem.WellPressure");
        rW_ = gridGeometry->bBoxMin()[0];
    }
```

First, we define the type of boundary conditions depending on the location. Two types of boundary  conditions
can be specified: Dirichlet or Neumann boundary condition. On a Dirichlet boundary, the values of the
primary variables need to be fixed. On a Neumann boundary condition, values for derivatives need to be fixed.

```cpp
    BoundaryTypes boundaryTypesAtPos(const GlobalPosition &globalPos) const
    {
        BoundaryTypes values;
        values.setAllDirichlet();
        return values;
    }
```

Second, we specify the values for the Dirichlet boundaries. We need to fix values of our primary variable

```cpp
    PrimaryVariables dirichletAtPos(const GlobalPosition &globalPos) const
    { return exactSolution(globalPos); }
```

We need to specify a constant temperature for our isothermal problem.
Fluid properties that depend on temperature will be calculated with this value.

```cpp
    Scalar temperature() const
    { return 283.15; }
```

This function defines the exact pressure solution

```cpp
    PrimaryVariables exactSolution(const GlobalPosition &globalPos) const
    {
        const auto r = globalPos[0];
        const auto p = pW_ - 1.0/(2*M_PI)*nu_/k_*q_*std::log(r/rW_);
        return p;
    }

private:
    Scalar q_, k_, nu_, rW_, pW_;
};

} // end namespace Dumux
```


</details>



## The spatial parameter class (`spatialparams.hh`)

<details open>
<summary><b>Click to hide/show the file documentation</b> (or inspect the [source code](spatialparams.hh))</summary>


```cpp
#include <dumux/material/spatialparams/fv1p.hh>

namespace Dumux {

template<class GridGeometry, class Scalar>
class RotSymExampleSpatialParams
: public FVSpatialParamsOneP<GridGeometry, Scalar, RotSymExampleSpatialParams<GridGeometry, Scalar>>
{
    using ThisType = RotSymExampleSpatialParams<GridGeometry, Scalar>;
    using ParentType = FVSpatialParamsOneP<GridGeometry, Scalar, ThisType>;
    using Element = typename GridGeometry::GridView::template Codim<0>::Entity;
    using GlobalPosition = typename Element::Geometry::GlobalCoordinate;
public:
    using PermeabilityType = Scalar;
    RotSymExampleSpatialParams(std::shared_ptr<const GridGeometry> gridGeometry)
    : ParentType(gridGeometry)
    { permeability_ = getParam<Scalar>("SpatialParams.Permeability"); }

    PermeabilityType permeabilityAtPos(const GlobalPosition& globalPos) const
    { return permeability_; }

    Scalar porosityAtPos(const GlobalPosition& globalPos) const
    { return 1.0; }
private:
    Scalar permeability_;
};

} // end namespace Dumux
```


</details>



## The properties (`properties.hh`)
This file defines the `TypeTag` used for the single-phase rotation symmetry simulation, for
which we then define the necessary properties.

<details open>
<summary><b>Click to hide/show the file documentation</b> (or inspect the [source code](properties.hh))</summary>

### Includes
<details><summary> Click to show includes</summary>

```cpp

#include <dune/grid/yaspgrid.hh> // for `Dune::YaspGrid`
#include <dumux/discretization/box.hh> // for `TTag::BoxModel`
```

The local residual for incompressible flow is included.
The one-phase flow model (included above) uses a default implementation of the
local residual for single-phase flow. However, in this example we are using an
incompressible fluid phase. Therefore, we are including the specialized local
residual which contains functionality to analytically compute the entries of
the Jacobian matrix. We will use this in the main file.

```cpp
#include <dumux/porousmediumflow/1p/model.hh> // for `TTag::OneP`
#include <dumux/porousmediumflow/1p/incompressiblelocalresidual.hh>

#include <dumux/material/components/constant.hh>
#include <dumux/material/fluidsystems/1pliquid.hh>
```

For rotational symmetric problems we use special geometry traits

```cpp
#include <dumux/discretization/rotationsymmetricgridgeometrytraits.hh>

#include "problem.hh"
#include "spatialparams.hh"
```

</details>

```cpp


namespace Dumux::Properties {
```

A `TypeTag` for our simulation is created which inherits from the one-phase flow model
and the cell centered finite volume scheme with two-point-flux discretization scheme:

```cpp
namespace TTag {
struct OnePRotSym { using InheritsFrom = std::tuple<OneP, BoxModel>; };
}
```

We use a structured 1D grid with an offset:

```cpp
template<class TypeTag>
struct Grid<TypeTag, TTag::OnePRotSym>
{ using type =  Dune::YaspGrid<1, Dune::EquidistantOffsetCoordinates<double, 1>>; };
```

Special grid geometry traits are needed

```cpp
template<class TypeTag>
struct GridGeometry<TypeTag, TTag::OnePRotSym>
{
    static constexpr bool enableCache = getPropValue<TypeTag, Properties::EnableGridGeometryCache>();
    using Scalar = GetPropType<TypeTag, Properties::Scalar>;
    using GridView = typename GetPropType<TypeTag, Properties::Grid>::LeafGridView;
    using GGTraits = RotationSymmetricGridGeometryTraits<BoxDefaultGridGeometryTraits<GridView>, RotationPolicy::disc>;

    using type = BoxFVGridGeometry<Scalar, GridView, enableCache, GGTraits>;
};
```

We use the local residual that contains analytic derivative methods for incompressible flow:

```cpp
template<class TypeTag>
struct LocalResidual<TypeTag, TTag::OnePRotSym>
{ using type = OnePIncompressibleLocalResidual<TypeTag>; };
```

The problem class specifies initial and boundary conditions:

```cpp
template<class TypeTag>
struct Problem<TypeTag, TTag::OnePRotSym>
{ using type = RotSymExampleProblem<TypeTag>; };
```

We define the spatial parameters for our simulation:

```cpp
template<class TypeTag>
struct SpatialParams<TypeTag, TTag::OnePRotSym>
{
    using GridGeometry = GetPropType<TypeTag, Properties::GridGeometry>;
    using Scalar = GetPropType<TypeTag, Properties::Scalar>;
    using type = RotSymExampleSpatialParams<GridGeometry, Scalar>;
};
```

In the following we define the fluid system to be used:

```cpp
template<class TypeTag>
struct FluidSystem<TypeTag, TTag::OnePRotSym>
{
    using Scalar = GetPropType<TypeTag, Properties::Scalar>;
    using type = FluidSystems::OnePLiquid<Scalar, Components::Constant<1, Scalar> >;
};

} // end namespace Dumux::Properties
```


</details>



## The main program (`main.cc`)
We look now at the main file for the tracer problem. We set up two problems in this file and solve them sequentially, first the 1p problem and afterwards the tracer problem. The result of the 1p problem is the pressure distribution in the problem domain. We use it to calculate the volume fluxes, which act as an input for the tracer problem. Based on this volume fluxes, we calculate the transport of a tracer in the following tracer problem.

<details open>
<summary><b>Click to hide/show the file documentation</b> (or inspect the [source code](main.cc))</summary>

### Includes
<details><summary> Click to show includes</summary>

```cpp

#include <config.h>

#include <iostream>
#include <dune/common/parallel/mpihelper.hh>

#include <dumux/common/properties.hh>
#include <dumux/common/parameters.hh>
#include <dumux/common/integrate.hh>

#include <dumux/linear/seqsolverbackend.hh>
#include <dumux/linear/pdesolver.hh>
#include <dumux/assembly/fvassembler.hh>
#include <dumux/assembly/diffmethod.hh>

#include <dumux/io/vtkoutputmodule.hh>
#include <dumux/io/grid/gridmanager_yasp.hh>

#include "properties.hh"
```

</details>
### Beginning of the main function

```cpp
int main(int argc, char** argv) try
{
    using namespace Dumux;
```

Convenience aliases for the type tag of the problem.

```cpp
    using TypeTag = Properties::TTag::OnePRotSym;
```

We initialize MPI. Finalization is done automatically on exit.

```cpp
    Dune::MPIHelper::instance(argc, argv);
```

We parse the command line arguments.

```cpp
    Parameters::init(argc, argv);
```

### Create the grid and the grid geometry

```cpp
    GridManager<GetPropType<TypeTag, Properties::Grid>> gridManager;
    gridManager.init();

    // We compute on the leaf grid view.
    const auto& leafGridView = gridManager.grid().leafGridView();
    using GridGeometry = GetPropType<TypeTag, Properties::GridGeometry>;
    auto gridGeometry = std::make_shared<GridGeometry>(leafGridView);
    gridGeometry->update();
```

### Initialise the problem

```cpp
    using Problem = GetPropType<TypeTag, Properties::Problem>;
    auto problem = std::make_shared<Problem>(gridGeometry);
```

a function to update the discrete analytical solution vector

```cpp
    const auto updateAnalyticalSolution = [&](auto& pExact)
    {
        pExact.resize(gridGeometry->numDofs());
        for (const auto& element : elements(gridGeometry->gridView()))
        {
            auto fvGeometry = localView(*gridGeometry);
            fvGeometry.bindElement(element);
            for (auto&& scv : scvs(fvGeometry))
                pExact[scv.dofIndex()] = problem->exactSolution(scv.dofPosition());
        }
    };

    using SolutionVector = GetPropType<TypeTag, Properties::SolutionVector>;
    SolutionVector p(gridGeometry->numDofs());
    SolutionVector pExact; updateAnalyticalSolution(pExact);

    using GridVariables = GetPropType<TypeTag, Properties::GridVariables>;
    auto gridVariables = std::make_shared<GridVariables>(problem, gridGeometry);
    gridVariables->init(p);

    VtkOutputModule<GridVariables, SolutionVector> vtkWriter(*gridVariables, p, problem->name());
    GetPropType<TypeTag, Properties::IOFields>::initOutputModule(vtkWriter);
    vtkWriter.addField(pExact, "pExact");

    using Assembler = FVAssembler<TypeTag, DiffMethod::analytic>;
    auto assembler = std::make_shared<Assembler>(problem, gridGeometry, gridVariables);

    using LinearSolver = UMFPackBackend;
    auto linearSolver = std::make_shared<LinearSolver>();
    LinearPDESolver<Assembler, LinearSolver> solver(assembler,  linearSolver);
    solver.setVerbose(false);
```

solve once with initial refinement

```cpp
    solver.solve(p);
```

compute initial L2 error

```cpp
    constexpr bool isBox = GridGeometry::discMethod == Dumux::DiscretizationMethod::box;
    constexpr int orderQuadratureRule = isBox ? 3 : 1;
    const int numRefinements = getParam<int>("Grid.RefinementSteps");
    std::vector<double> l2Errors(numRefinements);
    l2Errors[0] = integrateL2Error(*gridGeometry, p, pExact, orderQuadratureRule);
```

repeat for several refinements

```cpp
    for (int stepIdx = 1; stepIdx < numRefinements; stepIdx++)
    {
        // Globally refine the grid once
        gridManager.grid().globalRefine(1);
        gridGeometry->update();
        p.resize(gridGeometry->numDofs());
        updateAnalyticalSolution(pExact);
        gridVariables->updateAfterGridAdaption(p);
        assembler->setLinearSystem();

        // solve problem on refined grid
        solver.solve(p);

        // #### Post-processing and output
        // We calculate the L2 errors using the numerical solution
        l2Errors[stepIdx] = integrateL2Error(*gridGeometry, p, pExact, orderQuadratureRule);
        const auto numDofs = gridGeometry->numDofs();
        std::cout << std::setprecision(8) << std::scientific
                  << "-- L2 error for " << std::setw(5) << numDofs << " dofs: " << l2Errors[stepIdx]
                  << ", rate: " << std::log(l2Errors[stepIdx]/l2Errors[stepIdx-1])/std::log(0.5)
                  << std::endl;
    }
    // write vtk output on the finest grid
    vtkWriter.write(0.0);
```

program end, return with 0 exit code (success)

```cpp
    return 0;
}
```

### Exception handling
In this part of the main file we catch and print possible exceptions that could
occur during the simulation.
<details><summary> Click to show error handler</summary>

```cpp

catch (const Dumux::ParameterException &e)
{
    std::cerr << std::endl << e << " ---> Abort!" << std::endl;
    return 1;
}
catch (const Dune::DGFException & e)
{
    std::cerr << "DGF exception thrown (" << e <<
                 "). Most likely, the DGF file name is wrong "
                 "or the DGF file is corrupted, "
                 "e.g. missing hash at end of file or wrong number (dimensions) of entries."
                 << " ---> Abort!" << std::endl;
    return 2;
}
catch (const Dune::Exception &e)
{
    std::cerr << "Dune reported error: " << e << " ---> Abort!" << std::endl;
    return 3;
}
```

</details>

</details>

# Post-processing with ParaView

The result file `example_rotationsymmetry.pvd` can be opened with the software [ParaView](https://www.paraview.org/).
To obtain a visualisation as shown in the introduction of this documented example, after loading
the result file, choose `Filters`>`Alphabetical`>`Rotational Extrusion`.
You might have to reset your view and switch to `3D`. Then apply `Filters`>`Alphabetical`>`Warp By Scalar`.
