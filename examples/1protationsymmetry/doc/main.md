<!-- Important: This file has been automatically generated by generate_example_docs.py. Do not edit this file directly! -->


| [:arrow_left: Back to the main documentation](../README.md) | [:arrow_left: Go back to part 1](problem.md) | [:arrow_right: Continue with part 3](paraview.md) |
|---|---|---:|

# Part 2: Main program flow

We want to solve a rotational symmetric Laplace problem on a disc and
conduct a grid convergence study against an analytical solution.
The main program flow is implemented in file `main.cc` described below.

The code documentation is structured as follows:

[[_TOC_]]


## The main program (`main.cc`)
We look now at the main file for the tracer problem. We set up two problems in this file and solve them sequentially, first the 1p problem and afterwards the tracer problem. The result of the 1p problem is the pressure distribution in the problem domain. We use it to calculate the volume fluxes, which act as an input for the tracer problem. Based on this volume fluxes, we calculate the transport of a tracer in the following tracer problem.

<details open>
<summary><b>Click to hide/show the file documentation</b> (or inspect the [source code](../main.cc))</summary>

### Includes
<details><summary> Click to show includes</summary>

```cpp

#include <config.h>

#include <iostream>
#include <dune/common/parallel/mpihelper.hh>

#include <dumux/common/properties.hh>
#include <dumux/common/parameters.hh>
#include <dumux/common/integrate.hh>

#include <dumux/linear/seqsolverbackend.hh>
#include <dumux/linear/pdesolver.hh>
#include <dumux/assembly/fvassembler.hh>
#include <dumux/assembly/diffmethod.hh>

#include <dumux/io/vtkoutputmodule.hh>
#include <dumux/io/grid/gridmanager_yasp.hh>

#include "properties.hh"
```

</details>
### Beginning of the main function

```cpp
int main(int argc, char** argv) try
{
    using namespace Dumux;
```

Convenience aliases for the type tag of the problem.

```cpp
    using TypeTag = Properties::TTag::OnePRotSym;
```

We initialize MPI. Finalization is done automatically on exit.

```cpp
    Dune::MPIHelper::instance(argc, argv);
```

We parse the command line arguments.

```cpp
    Parameters::init(argc, argv);
```

### Create the grid and the grid geometry

```cpp
    GridManager<GetPropType<TypeTag, Properties::Grid>> gridManager;
    gridManager.init();

    // We compute on the leaf grid view.
    const auto& leafGridView = gridManager.grid().leafGridView();
    using GridGeometry = GetPropType<TypeTag, Properties::GridGeometry>;
    auto gridGeometry = std::make_shared<GridGeometry>(leafGridView);
    gridGeometry->update();
```

### Initialise the problem

```cpp
    using Problem = GetPropType<TypeTag, Properties::Problem>;
    auto problem = std::make_shared<Problem>(gridGeometry);
```

a function to update the discrete analytical solution vector

```cpp
    const auto updateAnalyticalSolution = [&](auto& pExact)
    {
        pExact.resize(gridGeometry->numDofs());
        for (const auto& element : elements(gridGeometry->gridView()))
        {
            auto fvGeometry = localView(*gridGeometry);
            fvGeometry.bindElement(element);
            for (auto&& scv : scvs(fvGeometry))
                pExact[scv.dofIndex()] = problem->exactSolution(scv.dofPosition());
        }
    };

    using SolutionVector = GetPropType<TypeTag, Properties::SolutionVector>;
    SolutionVector p(gridGeometry->numDofs());
    SolutionVector pExact; updateAnalyticalSolution(pExact);

    using GridVariables = GetPropType<TypeTag, Properties::GridVariables>;
    auto gridVariables = std::make_shared<GridVariables>(problem, gridGeometry);
    gridVariables->init(p);

    VtkOutputModule<GridVariables, SolutionVector> vtkWriter(*gridVariables, p, problem->name());
    GetPropType<TypeTag, Properties::IOFields>::initOutputModule(vtkWriter);
    vtkWriter.addField(pExact, "pExact");

    using Assembler = FVAssembler<TypeTag, DiffMethod::analytic>;
    auto assembler = std::make_shared<Assembler>(problem, gridGeometry, gridVariables);

    using LinearSolver = UMFPackBackend;
    auto linearSolver = std::make_shared<LinearSolver>();
    LinearPDESolver<Assembler, LinearSolver> solver(assembler,  linearSolver);
    solver.setVerbose(false);
```

solve once with initial refinement

```cpp
    solver.solve(p);
```

compute initial L2 error

```cpp
    constexpr bool isBox = GridGeometry::discMethod == Dumux::DiscretizationMethod::box;
    constexpr int orderQuadratureRule = isBox ? 3 : 1;
    const int numRefinements = getParam<int>("Grid.RefinementSteps");
    std::vector<double> l2Errors(numRefinements);
    l2Errors[0] = integrateL2Error(*gridGeometry, p, pExact, orderQuadratureRule);
```

repeat for several refinements

```cpp
    for (int stepIdx = 1; stepIdx < numRefinements; stepIdx++)
    {
        // Globally refine the grid once
        gridManager.grid().globalRefine(1);
        gridGeometry->update();
        p.resize(gridGeometry->numDofs());
        updateAnalyticalSolution(pExact);
        gridVariables->updateAfterGridAdaption(p);
        assembler->setLinearSystem();

        // solve problem on refined grid
        solver.solve(p);

        // #### Post-processing and output
        // We calculate the L2 errors using the numerical solution
        l2Errors[stepIdx] = integrateL2Error(*gridGeometry, p, pExact, orderQuadratureRule);
        const auto numDofs = gridGeometry->numDofs();
        std::cout << std::setprecision(8) << std::scientific
                  << "-- L2 error for " << std::setw(5) << numDofs << " dofs: " << l2Errors[stepIdx]
                  << ", rate: " << std::log(l2Errors[stepIdx]/l2Errors[stepIdx-1])/std::log(0.5)
                  << std::endl;
    }
    // write vtk output on the finest grid
    vtkWriter.write(0.0);
```

program end, return with 0 exit code (success)

```cpp
    return 0;
}
```

### Exception handling
In this part of the main file we catch and print possible exceptions that could
occur during the simulation.
<details><summary> Click to show error handler</summary>

```cpp

catch (const Dumux::ParameterException &e)
{
    std::cerr << std::endl << e << " ---> Abort!" << std::endl;
    return 1;
}
catch (const Dune::DGFException & e)
{
    std::cerr << "DGF exception thrown (" << e <<
                 "). Most likely, the DGF file name is wrong "
                 "or the DGF file is corrupted, "
                 "e.g. missing hash at end of file or wrong number (dimensions) of entries."
                 << " ---> Abort!" << std::endl;
    return 2;
}
catch (const Dune::Exception &e)
{
    std::cerr << "Dune reported error: " << e << " ---> Abort!" << std::endl;
    return 3;
}
```

</details>

</details>


| [:arrow_left: Back to the main documentation](../README.md) | [:arrow_left: Go back to part 1](problem.md) | [:arrow_right: Continue with part 3](paraview.md) |
|---|---|---:|

